<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Territorial â€” Stable Final (With Effects)</title>
<style>
/* styles omitted for brevity â€” same as original (kept intact) */
html,body{margin:0;padding:0;overflow:hidden;background:#0d1117;font-family:Tahoma,Arial,sans-serif}
canvas{display:block;touch-action:none}
#lobby{position:fixed;inset:0;z-index:2000;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#0d1117,#111827,#1a2333);animation:bgMove 8s infinite alternate}
@keyframes bgMove{0%{filter:brightness(1)}100%{filter:brightness(1.12)}}
.card{background:rgba(6,10,18,0.7);backdrop-filter:blur(8px);padding:24px;border-radius:14px;width:360px;box-shadow:0 12px 40px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.04);color:#e6eef8}
.card h1{margin:0 0 12px;font-size:20px;text-align:center}
#telegramTag{font-size:20px;font-weight:700;color:#ff3333;text-align:center;margin-bottom:10px;text-shadow:0 0 8px rgba(255,0,0,0.12),0 0 18px rgba(255,0,0,0.06)}
label{display:block;color:#aeb9c8;margin-top:10px}
select,input[type=range]{width:100%;margin:8px 0;padding:10px;border-radius:10px;border:none;background:#101521;color:#fff}
button{padding:12px;border-radius:10px;border:none;cursor:pointer;font-weight:700}
.green{background:#16a34a;color:white}
#ratioBar{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(255,255,255,0.92);padding:10px 12px;border-radius:14px;display:flex;align-items:center;gap:12px;z-index:1800}
#ratioBar input{width:160px}
#legend{position:fixed;left:12px;top:12px;z-index:1800;color:white;display:flex;flex-direction:column;gap:6px}
.legend-item{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:8px}
#dbg{position:fixed;right:8px;bottom:8px;z-index:2200;background:rgba(0,0,0,0.7);color:#fff;padding:8px;border-radius:8px;font-size:12px;display:none;max-width:40vw}
#mainMenuBtn{position:fixed;right:12px;top:12px;z-index:2100;background:#2563eb;color:white;padding:8px 12px;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,0.3);cursor:pointer}
#victoryOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:3000}
#victoryCard{background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.03));backdrop-filter:blur(8px);padding:28px;border-radius:16px;text-align:center;color:white;box-shadow:0 30px 80px rgba(0,0,0,0.6)}
#victoryCard h1{margin:8px 0 6px 0;font-size:32px}
#victoryCard .crown{font-size:46px;filter:drop-shadow(0 8px 20px rgba(255,215,0,0.3))}
#victoryCard button{margin-top:12px;padding:10px 16px;border-radius:10px;border:none;cursor:pointer}
</style>
</head>
<body>
<div id="pingDisplay" style="position:absolute;top:60px;right:14px;color:white;font-size:18px;display:none;pointer-events:none;z-index:2500;">0 ms</div>

<canvas id="game"></canvas>
<canvas id="lineLayer" style="position:fixed;inset:0;pointer-events:none;z-index:1700"></canvas>

<div id="ratioBar" aria-hidden="false">
  <span style="font-weight:700">Ø§Ù„Ù‚ÙˆØ§Øª:</span>
  <input id="ratioSlider" type="range" min="10" max="100" value="50">
  <span id="ratioValue">50%</span>
</div>

<div id="mainMenuBtn" role="button">âŸµ Ø±Ø¬ÙˆØ¹</div>

<div id="lobby" role="dialog" aria-label="Lobby">
  <div class="card">
    <h1>Ù„ÙˆØ¨ÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø©</h1>
    <div id="telegramTag">@Z_S_T_O</div>

    <label>Ø¹Ø¯Ø¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†</label>
    <select id="playerCount">
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4" selected>4</option>
    </select>

    <label>Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¥Ù†ØªØ§Ø¬ (Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©)</label>
    <input id="prodRate" type="range" min="300" max="2000" value="900">

    <div style="margin-top:12px">
      <button id="startBtn" class="green" style="width:100%">Ø§Ø¨Ø¯Ø£</button>
<button id="pingToggle" title="Ping (P)" style="position:absolute;left:55px;top:10px;width:40px;height:40px;background:#a00;color:#fff;font-size:22px;border:none;border-radius:10px;cursor:pointer;font-weight:700">P</button>
    <button id="onlineBtnLocal" class="green" style="width:100%;background:#06b6d4;margin-top:8px">Ø§ÙˆÙ†Ù„Ø§ÙŠÙ† (ØºØ±Ù)</button>
    </div>
  </div>
</div>


<!-- FULLSCREEN ONLINE PAGE -->
<div id="onlinePage" style="display:none;position:fixed;inset:0;z-index:3000;background:linear-gradient(180deg,#0d1117,#071022);color:#e6eef8;overflow:auto;padding:36px 12px">
  <div style="max-width:840px;margin:0 auto">
    <div style="display:flex;justify-content:flex-end;gap:8px">
      <button id="onlineBack" style="background:#111827;color:white;padding:8px 12px;border-radius:10px;cursor:pointer">Ø±Ø¬ÙˆØ¹ âŸµ</button>
      <button id="leaveRoomBtn" style="background:#ef4444;color:white;padding:8px 12px;border-radius:10px;cursor:pointer;display:none">Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„ØºØ±ÙØ©</button>
    </div>
    <h1 style="text-align:center;margin:18px 0;font-size:28px">Ø§ÙˆÙ†Ù„Ø§ÙŠÙ† â€” Ù†Ø¸Ø§Ù… Ø§Ù„ØºØ±Ù</h1>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:18px">
      <div style="background:rgba(6,10,18,0.7);padding:18px;border-radius:12px">
        <h2 style="margin:0 0 8px">Ø¥Ù†Ø´Ø§Ø¡ ØºØ±ÙØ©</h2>
        <input id="roomName" placeholder="Ø§Ø³Ù… Ø§Ù„ØºØ±ÙØ© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)" style="width:100%;padding:10px;border-radius:8px;border:none;background:#0b1220;color:#fff;margin-bottom:8px">
        <label style="display:block;margin-bottom:6px">Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†</label>
        <select id="roomMax" style="width:100%;padding:10px;border-radius:8px;border:none;background:#0b1220;color:#fff;margin-bottom:10px">
          <option value="2">2 Ù„Ø§Ø¹Ø¨ÙŠÙ†</option><option value="3">3 Ù„Ø§Ø¹Ø¨ÙŠÙ†</option><option value="4" selected>4 Ù„Ø§Ø¹Ø¨ÙŠÙ†</option>
        </select>
        <div style="display:flex;gap:8px">
          <button id="createRoom" class="green" style="flex:1">Ø¥Ù†Ø´Ø§Ø¡</button>
          <button id="startRoom" style="flex:1;background:#10b981;color:#fff;border-radius:8px;border:none;cursor:pointer">Ø¨Ø¯Ø¡ (Ù…Ø¶ÙŠÙ ÙÙ‚Ø·)</button>
        </div>
        <div id="roomInfo" style="margin-top:10px;font-size:13px;color:#9fb2c6"></div>
      </div>
      <div style="background:rgba(6,10,18,0.7);padding:18px;border-radius:12px">
        <h2 style="margin:0 0 8px">Ø§Ù†Ø¶Ù…Ø§Ù… Ù„ØºØ±ÙØ©</h2>
        <input id="joinCode" placeholder="Ø±Ù…Ø² Ø§Ù„ØºØ±ÙØ©" style="width:100%;padding:10px;border-radius:8px;border:none;background:#0b1220;color:#fff;margin-bottom:8px">
        <button id="joinRoom" class="green" style="width:100%">Ø§Ù†Ø¶Ù…Ø§Ù…</button>
        <div style="margin-top:12px">
          <h3 style="margin:0 0 6px">Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† ÙÙŠ Ø§Ù„ØºØ±ÙØ©</h3>
          <ul id="playerList" style="list-style:none;padding:0;margin:0;color:#dbeafe"></ul>
        </div>
      </div>
    </div>
    <div style="margin-top:18px;color:#9fb2c6;font-size:13px">Ù…Ù„Ø§Ø­Ø¸Ø©: Ø§Ù„Ø£ÙˆÙ†Ù„Ø§ÙŠÙ† ÙŠØ¹Ù…Ù„ Ø¨Ù†Ø¸Ø§Ù… WebSocket. Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© ØªÙƒÙˆÙ† Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ù…ØªØ²Ø§Ù…Ù†Ø© Ø¨ÙŠÙ† Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø¨Ø¯ÙˆÙ† Ø¨ÙˆØªØ§Øª.</div>
  </div>
</div>

<div id="legend" aria-hidden="true"></div>
<div id="dbg" role="status"></div>

<div id="victoryOverlay"><div id="victoryCard"><div class="crown">ğŸ‘‘</div><h1 id="victoryText"></h1><div id="victorName" style="font-size:20px;margin-top:6px"></div><button id="victoryToLobby" class="green">Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‘ÙˆØ¨ÙŠ</button></div></div>

<script>
var grid = [];

document.addEventListener('DOMContentLoaded', ()=>{
  'use strict';
  const HEX = 34;
  const DEFEND_RADIUS = HEX * 3.2;
  const gameCanvas = document.getElementById('game');
  const lineCanvas = document.getElementById('lineLayer');
  const dbg = document.getElementById('dbg');
  const ratioSlider = document.getElementById('ratioSlider');
  const ratioValue = document.getElementById('ratioValue');
  const startBtn = document.getElementById('startBtn');
  const playerCount = document.getElementById('playerCount');
  const prodRate = document.getElementById('prodRate');
  const legendEl = document.getElementById('legend');
  const mainMenuBtn = document.getElementById('mainMenuBtn');
  const victoryOverlay = document.getElementById('victoryOverlay');
  const victoryText = document.getElementById('victoryText');
  const victorName = document.getElementById('victorName');
  const victoryToLobby = document.getElementById('victoryToLobby');

  if(!gameCanvas || !lineCanvas){ dbg.style.display='block'; dbg.textContent='Ø®Ø·Ø£: Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø±Ø³Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©'; return; }
  const ctx = gameCanvas.getContext('2d');
  const lctx = lineCanvas.getContext('2d');
  if(!ctx || !lctx){ dbg.style.display='block'; dbg.textContent='Ø®Ø·Ø£: ØªØ¹Ø°Ø± Ø¥Ù†Ø´Ø§Ø¡ Ø³ÙŠØ§Ù‚ 2D'; return; }

  let W = 0, H = 0;
  let needRender = true;
  // Expose a global hook so socket-client can request a render safely
  window.requestRender = function(){ try{ needRender = true; }catch(e){} };
  // expose render function reference placeholder (will be assigned once render exists)
  window.render = window.render || null;
  function resize(){ W = gameCanvas.width = window.innerWidth || 300; H = gameCanvas.height = window.innerHeight || 200; lineCanvas.width = W; lineCanvas.height = H; needRender = true; }
  window.addEventListener('resize', resize);
  resize();

  var players = [];
  var cam = { x:0, y:0, scale:1 };
  // expose cam so external code (server/client) can center camera on capital
  window.cam = cam;
  var selected = null;
  var animations = [];
  var effects = [];
  var prodTimer = null, botTimer = null;
  var dragging = false, lastX = 0, lastY = 0;

  // helper flags
  window.isOnline = false;
  window.isInRoom = false;

  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioCtx ? new AudioCtx() : null;
  function playTone(freq, duration=0.3, type='sine'){ if(!audioCtx) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = type; o.frequency.value = freq; o.connect(g); g.connect(audioCtx.destination); const now = audioCtx.currentTime; g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.12, now + 0.01); o.start(now); g.gain.exponentialRampToValueAtTime(0.0001, now + duration); o.stop(now + duration + 0.02); }
  function playVictorySound(){ playTone(880,0.5,'sine'); setTimeout(()=>playTone(660,0.35,'sine'),120); }
  function playEliminatedSound(){ playTone(180,0.22,'sawtooth'); }
  function playCaptureSound(){ playTone(520,0.18,'triangle'); }
  function playCapitalCapture(){ playTone(760,0.45,'sine'); setTimeout(()=>playTone(520,0.3,'triangle'),160); }

  function renderSafe(){ try{ updateAnimations(16); render(); }catch(e){ console.error(e); dbg.style.display='block'; dbg.textContent = String(e); } }

  function HEXR(){ return HEX; }
  function buildGrid(){
    grid.length = 0;
    const cols = Math.max(8, Math.floor(W / (HEXR() * 1.6)));
    const rows = Math.max(6, Math.floor(H / (HEXR() * 1.25)));
    const startX = -cols * HEX * 0.85;
    const startY = -rows * HEX * 0.95;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = startX + c * HEX * 1.7 + (r % 2 ? HEX * 0.85 : 0);
        const y = startY + r * HEX * 1.45;
        grid.push({ x, y, owner:null, troops:0, neighbors:[] });
      }
    }
    for(let i=0;i<grid.length;i++){
      const a = grid[i];
      for(let j=0;j<grid.length;j++){
        if(i===j) continue;
        const b = grid[j];
        if(Math.hypot(a.x - b.x, a.y - b.y) < HEX * 1.75) a.neighbors.push(j);
      }
    }
    needRender = true;
  }

  function worldToScreen(x,y){ return { x:(x + cam.x) * cam.scale + W/2, y:(y + cam.y) * cam.scale + H/2 }; }
  function screenToWorld(sx,sy){ return { x:(sx - W/2) / cam.scale - cam.x, y:(sy - H/2) / cam.scale - cam.y }; }
  function drawHex(cx,cy,r){ ctx.beginPath(); for(let i=0;i<6;i++){ const a=Math.PI/3*i + Math.PI/6; const x=cx+Math.cos(a)*r; const y=cy+Math.sin(a)*r; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.closePath(); }
  function cellAt(wx,wy){ if(!grid || grid.length===0) return null; let best=null, bd=HEX*1.05; for(let i=0;i<grid.length;i++){ const d=Math.hypot(grid[i].x-wx, grid[i].y-wy); if(d<bd){ bd=d; best=i; } } return best; }
  function isNeighbor(a,b){ if(!grid||!grid[a]||!grid[b]) return false; return Math.hypot(grid[a].x-grid[b].x, grid[a].y-grid[b].y) < HEX * 1.8; }

  function setupPlayers(n){
    players = [];
    // fixed 4-color pool (red, blue, green, yellow)
    const colorPool = ['#ff5555','#3399ff','#00c48c','#ffe047'];
    for(let i=0;i<n;i++){
      // assign colors in order, reuse if n>4
      const color = colorPool[i % colorPool.length];
      players.push({ id:i, color:color, name:'P'+(i+1), capital:null, alive:true });
    }
    updateLegend();
    needRender = true;
  }

  function seedCapitals(){
    if(!grid || grid.length===0) buildGrid();
    grid.forEach(c => { c.owner=null; c.troops=0; });

    const xs = grid.map(c=>c.x), ys = grid.map(c=>c.y);
    const cxMin = Math.min(...xs), cxMax = Math.max(...xs);
    const cyMin = Math.min(...ys), cyMax = Math.max(...ys);
    const corners = [[cxMin,cyMin],[cxMax,cyMin],[cxMin,cyMax],[cxMax,cyMax]];

    for(let p=0; p<players.length; p++){
      const pt = corners[p % corners.length];
      let bestIdx=0, bestD=Infinity;
      for(let i=0; i<grid.length; i++){
        const d = Math.hypot(grid[i].x - pt[0], grid[i].y - pt[1]);
        if(d < bestD){ bestD = d; bestIdx = i; }
      }
      grid[bestIdx].owner = players[p].id;
      grid[bestIdx].troops = 40;
      players[p].capital = bestIdx;
    }
    needRender = true;
  }

  function startProduction(ms){ if(prodTimer) clearInterval(prodTimer); prodTimer = setInterval(()=>{ if(grid && grid.length) grid.forEach(c=>{ if(c.owner != null) c.troops++; }); }, Math.max(50, parseInt(ms,10) || 900)); }

  function animateMove(fromIdx,toIdx,color){ if(!grid||!grid[fromIdx]||!grid[toIdx]) return; animations.push({ fromIdx,toIdx,color,t:0 }); needRender = true; }
  function updateAnimations(delta){ lctx.clearRect(0,0,W,H); if(!grid||grid.length===0) return; const remaining=[]; for(const a of animations){ a.t += delta*0.004; if(a.t>=1) continue; const A = worldToScreen(grid[a.fromIdx].x, grid[a.fromIdx].y); const B = worldToScreen(grid[a.toIdx].x, grid[a.toIdx].y); const x = A.x + (B.x - A.x) * a.t; const y = A.y + (B.y - A.y) * a.t; lctx.beginPath(); lctx.fillStyle = a.color; lctx.arc(x,y,6*Math.max(0.6,cam.scale),0,Math.PI*2); lctx.fill(); remaining.push(a); } animations = remaining; if(animations.length>0) needRender = true; }

  function captureEffect(cellIdx){
    const cell = grid[cellIdx]; if(!cell) return;
    const s = worldToScreen(cell.x, cell.y);
    effects.push({ type:'pulse', x:s.x, y:s.y, r:0, t:0, max: Math.max(W,H)*0.12 });
    playCapitalCapture();
    needRender = true;
  }

  function updateEffects(dt){
    lctx.clearRect(0,0,W,H);
    const keep = [];
    for(const e of effects){
      e.t += dt;
      if(e.type==='pulse'){
        e.r = e.t * 0.4 * (1 + cam.scale);
        const alpha = Math.max(0, 0.8 - e.t*0.008);
        lctx.beginPath(); lctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
        lctx.strokeStyle = 'rgba(255,215,80,'+alpha+')';
        lctx.lineWidth = Math.max(2, 6 * cam.scale);
        lctx.stroke();
        if(e.t < 80){ lctx.fillStyle = 'rgba(255,240,200,' + (0.12 + (80 - e.t)/800) + ')'; lctx.beginPath(); lctx.arc(e.x, e.y, Math.min(e.r, e.max*0.25), 0, Math.PI*2); lctx.fill(); }
        if(e.t < 220) keep.push(e);
      }
    }
    effects.length = 0; Array.prototype.push.apply(effects, keep);
    if(keep.length>0) needRender = true;
  }

  function moveTroops(fromIdx,toIdx,ratio){
    if(!grid||!grid[fromIdx]||!grid[toIdx]) return;
    const f = grid[fromIdx], t = grid[toIdx];
    const send = Math.floor(f.troops * ratio);
    if(send <= 0) return;
    f.troops = Math.max(0, f.troops - send);
    animateMove(fromIdx,toIdx, players[f.owner] ? players[f.owner].color : '#fff');
    if(t.owner === f.owner){ t.troops += send; }
    else {
      if(send > t.troops){
        const defeatedOwner = t.owner;
        t.owner = f.owner;
        t.troops = send - t.troops;
        playCaptureSound();
        if(defeatedOwner != null && players[defeatedOwner] && players[defeatedOwner].capital === toIdx){
          if(players[defeatedOwner]) players[defeatedOwner].alive = false;
          for(const c of grid){ if(c.owner === defeatedOwner){ c.owner = null; c.troops = 0; } }
          playEliminatedSound();
          captureEffect(toIdx);
          if(f.owner === 0) playVictorySound();
          checkVictory();
        }
      } else {
        t.troops = Math.max(0, t.troops - send);
      }
    }
    needRender = true;
  }

  function botTick(){ /* bots only used in offline mode; in online we stop botTimer */ 
    if(!grid||grid.length===0) return;
    for(let p=1;p<players.length;p++){
      const bot = players[p];
      if(!bot || !bot.alive) continue;
      const ownedIdx = grid.map((c,i)=>c.owner===p?i:null).filter(i=>i!==null);
      if(ownedIdx.length===0) continue;
      const borderCells = [];
      for(const i of ownedIdx){
        const cell = grid[i];
        if(!cell) continue;
        for(const n of cell.neighbors){
          if(grid[n] && grid[n].owner != null && grid[n].owner !== p){
            borderCells.push(i);
            break;
          }
        }
      }
      for(const border of borderCells){
        if(grid[border].troops > 6) continue;
        const candidates = ownedIdx.filter(i=>i!==border && grid[i].troops>6);
        if(candidates.length===0) continue;
        candidates.sort((a,b)=> Math.hypot(grid[a].x - grid[border].x, grid[a].y - grid[border].y) - Math.hypot(grid[b].x - grid[border].x, grid[b].y - grid[border].y));
        moveTroops(candidates[0], border, 0.6);
      }
    }
    for(let p=1;p<players.length;p++){
      const bot = players[p];
      if(!bot || !bot.alive) continue;
      const capIdx = bot.capital;
      if(typeof capIdx === 'number' && capIdx != null){
        const cap = grid[capIdx];
        if(cap){
          const defendRadius = HEX * 3.2;
          let threat = null;
          let threatDist = Infinity;
          for(let i=0;i<grid.length;i++){
            const cell = grid[i];
            if(cell.owner != null && cell.owner !== p){
              const d = Math.hypot(cell.x - cap.x, cell.y - cap.y);
              if(d < defendRadius && d < threatDist){
                threatDist = d;
                threat = i;
              }
            }
          }
          if(threat != null){
            const friendlyCells = grid.map((c,idx)=> c.owner===p && c.troops>6 ? idx : null).filter(i=>i!==null);
            if(friendlyCells.length>0){
              friendlyCells.sort((a,b)=> Math.hypot(grid[a].x-cap.x,grid[a].y-cap.y)-Math.hypot(grid[b].x-cap.x,grid[b].y-cap.y));
              const origin = friendlyCells[0];
              moveTroops(origin, threat, 0.75);
              continue;
            }
          }
        }
      }
      const ownedIdx = grid.map((c,i)=>c.owner===p?i:null).filter(i=>i!==null);
      if(ownedIdx.length===0) continue;
      const originIdx = ownedIdx[Math.floor(Math.random()*ownedIdx.length)];
      const origin = grid[originIdx];
      if(!origin||origin.troops<5) continue;
      const neighIdx = origin.neighbors.slice();
      if(neighIdx.length===0) continue;
      let weakestIdx = neighIdx[0];
      for(const ni of neighIdx) if(grid[ni].troops < grid[weakestIdx].troops) weakestIdx = ni;
      moveTroops(originIdx, weakestIdx, 0.5);
    }
  }

  function drawCapitalMarker(cellIdx){ if(!grid[cellIdx]) return; const c = grid[cellIdx]; const s = worldToScreen(c.x, c.y); ctx.beginPath(); ctx.lineWidth = Math.max(2, 3 * cam.scale); ctx.strokeStyle = 'rgba(255,215,0,0.95)'; ctx.arc(s.x, s.y, HEX * cam.scale + 6 * cam.scale, 0, Math.PI*2); ctx.stroke(); ctx.fillStyle = 'rgba(255,215,0,0.95)'; ctx.font = (18 * Math.max(0.7, cam.scale)) + 'px Tahoma'; ctx.textAlign = 'center'; ctx.fillText('â˜…', s.x, s.y - (HEX * cam.scale + 4 * cam.scale)); }

  function render(){ if(!ctx) return; if(!needRender && animations.length===0 && effects.length===0) return;
    ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,W,H); ctx.fillStyle = '#0d1117'; ctx.fillRect(0,0,W,H); if(!grid||grid.length===0) return;
    for(let i=0;i<grid.length;i++){ const c = grid[i]; const s = worldToScreen(c.x, c.y); drawHex(s.x, s.y, HEX * cam.scale); ctx.fillStyle = c.owner == null ? '#ffffff' : players[c.owner] ? players[c.owner].color : '#fff'; ctx.fill(); if(i === selected){ ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 3; ctx.stroke(); } ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.font = (14 * Math.max(0.7, cam.scale)) + 'px Tahoma'; ctx.fillText(c.troops, s.x, s.y + (5 * cam.scale)); }
    for(const p of players){
      if(p && typeof p.capital === 'number' && p.alive && window.grid && window.grid[p.capital] && window.grid[p.capital].owner === p.id){
        drawCapitalMarker(p.capital);
      }
    }
    const now = performance.now();
    for(const p of players){ if(!p || p.capital==null || !p.alive) continue; const capIdx = p.capital; const cap = grid[capIdx]; if(!cap) continue; let danger=false; for(let i=0;i<grid.length;i++){ const cell = grid[i]; if(cell.owner != null && cell.owner !== p.id){ const d = Math.hypot(cell.x - cap.x, cell.y - cap.y); if(d < DEFEND_RADIUS){ danger=true; break; } } } if(danger){ const s = worldToScreen(cap.x, cap.y); const blink = 0.5 + 0.5 * Math.sin(now * 0.015); ctx.save(); ctx.translate(s.x, s.y - (HEX * cam.scale + 18 * cam.scale)); ctx.scale(cam.scale, cam.scale); ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(7, 8); ctx.lineTo(-7, 8); ctx.closePath(); ctx.fillStyle = 'rgba(255,80,80,'+blink+')'; ctx.fill(); ctx.restore(); } }
    needRender = false;
  }
  // expose render to external scripts
  window.render = render;


  function updateLegend(){ if(!legendEl) return; legendEl.innerHTML = ''; for(const p of players){ const div = document.createElement('div'); div.className = 'legend-item'; div.innerHTML = `<div style="width:14px;height:10px;background:${p.color};border-radius:4px"></div><div style="font-size:13px">${p.name}</div>`; legendEl.appendChild(div); } }

  function updateEffectsAndAnimations(dt){ updateAnimations(dt); updateEffects(dt); }

  function checkVictory(){ const alive = players.filter(p=>p && p.alive); if(alive.length===1){ const winner = alive[0]; if(prodTimer) clearInterval(prodTimer); if(botTimer) clearInterval(botTimer); victoryText.textContent = 'Ø§Ù„ÙØ§Ø¦Ø² Ù‡Ùˆ:'; victorName.textContent = winner.name; victoryOverlay.style.display = 'flex'; playVictorySound(); } }

  function returnToLobby(){ if(prodTimer) clearInterval(prodTimer); if(botTimer) clearInterval(botTimer); victoryOverlay.style.display = 'none'; document.getElementById('lobby').style.display = 'flex'; buildGrid(); setupPlayers(parseInt(playerCount.value,10)||4); seedCapitals(); updateLegend(); render(); }
  if(mainMenuBtn) mainMenuBtn.addEventListener('click', returnToLobby); if(victoryToLobby) victoryToLobby.addEventListener('click', returnToLobby);

  if(ratioSlider && ratioValue) ratioSlider.addEventListener('input', e=> ratioValue.textContent = e.target.value + '%');
  gameCanvas.addEventListener('pointerdown', e=>{ dragging = true; lastX = e.clientX; lastY = e.clientY; gameCanvas.setPointerCapture && gameCanvas.setPointerCapture(e.pointerId); needRender = true; });
  gameCanvas.addEventListener('pointerup', e=>{ dragging = false; gameCanvas.releasePointerCapture && gameCanvas.releasePointerCapture(e.pointerId); needRender = true; });
  gameCanvas.addEventListener('pointermove', e=>{ if(!dragging) return; cam.x += (e.clientX - lastX) / cam.scale; cam.y += (e.clientY - lastY) / cam.scale; lastX = e.clientX; lastY = e.clientY; needRender = true; });
  gameCanvas.addEventListener('click', e=>{ const pos = screenToWorld(e.clientX, e.clientY); const idx = cellAt(pos.x, pos.y); if(idx == null) return; const cell = grid[idx]; const isOnlineNow = window.isInRoom; if(selected === null){ // select only if player owns it (offline owner=0, online owner === my index)
      const myIndex = (window.socketClient && window.socketClient.getPlayerIndex) ? window.socketClient.getPlayerIndex() : 0;
      if(isOnlineNow){
        if(cell.owner === myIndex) selected = idx;
      } else {
        if(cell.owner === 0) selected = idx;
      }
    } else {
      if(idx !== selected && isNeighbor(selected, idx)){
        const ratio = ratioSlider ? parseInt(ratioSlider.value,10)/100 : 0.5;
        if(window.isInRoom && window.socketClient){
          // optimistic local update for smoothness
          try{
            moveTroops(selected, idx, ratio);
            // send action to server
            window.socketClient.sendAction({ type:'move', from:selected, to:idx, ratio });
          }catch(e){ console.warn('online move failed', e); }
        } else {
          moveTroops(selected, idx, ratio);
        }
      }
      selected = null;
    } needRender = true; });

  function startGame(){ try{ if(!grid || grid.length < 8) buildGrid(); const cnt = playerCount ? Math.max(2, Math.min(4, parseInt(playerCount.value,10) || 4)) : 4; setupPlayers(cnt); seedCapitals(); startProduction(prodRate ? parseInt(prodRate.value,10) : 900); if(botTimer) clearInterval(botTimer); botTimer = setInterval(botTick, 900); document.getElementById('lobby').style.display = 'none'; updateLegend(); needRender = true; }catch(err){ console.error(err); dbg.style.display='block'; dbg.textContent = String(err); } }
  window.startGame = startGame; if(startBtn) startBtn.addEventListener('click', startGame);

  let last = performance.now(); function frame(now){ const dt = now - last; last = now; try{ updateEffectsAndAnimations(dt); if(needRender || animations.length>0 || effects.length>0){ render(); } }catch(e){ console.error(e); dbg.style.display='block'; dbg.textContent = String(e); } requestAnimationFrame(frame); } requestAnimationFrame(frame);

  buildGrid(); setupPlayers(4); seedCapitals(); updateLegend(); needRender = true;

});
</script>

<!-- DEBUG CONSOLE (toggle with M) -->
<button id="debugToggle" title="Toggle Console (M)" style="position:fixed;left:12px;top:12px;z-index:4000;background:rgba(255,255,255,0.06);color:#fff;border:none;padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:700">M</button>
<div id="debugConsole" style="display:none;position:fixed;left:12px;top:56px;z-index:4000;width:360px;max-height:60vh;overflow:auto;background:rgba(2,6,23,0.9);border-radius:10px;padding:8px;color:#d1d5db;box-shadow:0 12px 40px rgba(0,0,0,0.6)">
  <div style="display:flex;justify-content:flex-end"><button id="closeConsole" style="background:transparent;border:none;color:#f87171;font-weight:700;cursor:pointer">X</button></div>
  <pre id="consoleLog" style="white-space:pre-wrap;font-size:12px;margin:0;height:60vh;overflow:auto"></pre>
</div>


<script src="socket-client.js"></script>
<script>
// Debug logger helper used by socket client and page
window.debugLogs = [];
function debugLog(msg){
  try{
    const pre = document.getElementById('consoleLog');
    const time = new Date().toLocaleTimeString();
    const line = '['+time+'] ' + (typeof msg === 'object' ? JSON.stringify(msg) : msg);
    window.debugLogs.push(line);
    if(pre){
      pre.textContent = window.debugLogs.slice(-500).join("\n") + "\n";
      pre.scrollTop = pre.scrollHeight;
    }
    console.log('DEBUG:', msg);
  }catch(e){ console.log('debugLog failed', e); }
}

// Toggle debug console with M and button
document.addEventListener('keydown', function(e){
  if(e.key && e.key.toLowerCase() === 'm'){ toggleConsole(); }
});
document.getElementById('debugToggle').addEventListener('click', toggleConsole);
document.getElementById('closeConsole').addEventListener('click', toggleConsole);
function toggleConsole(){
  const el = document.getElementById('debugConsole');
  if(!el) return;
  el.style.display = (el.style.display === 'none' ? 'block' : 'none');
}

// Online page wiring
const onlineBtnLocal = document.getElementById('onlineBtnLocal');
const onlinePage = document.getElementById('onlinePage');
const onlineBack = document.getElementById('onlineBack');
const createRoomBtn = document.getElementById('createRoom');
const joinRoomBtn = document.getElementById('joinRoom');
const startRoomBtn = document.getElementById('startRoom');
const roomInfo = document.getElementById('roomInfo');
const playerList = document.getElementById('playerList');
const joinCodeInput = document.getElementById('joinCode');
const roomNameInput = document.getElementById('roomName');
const roomMaxSelect = document.getElementById('roomMax');
const leaveRoomBtn = document.getElementById('leaveRoomBtn');

onlineBtnLocal && onlineBtnLocal.addEventListener('click', ()=>{ onlinePage.style.display='block'; document.getElementById('lobby').style.display='none'; });
onlineBack && onlineBack.addEventListener('click', ()=>{ onlinePage.style.display='none'; document.getElementById('lobby').style.display='flex'; });

// socketClient assumed to be loaded via socket-client.js
createRoomBtn && createRoomBtn.addEventListener('click', ()=>{
  const name = roomNameInput.value || null;
  const maxPlayers = parseInt(roomMaxSelect.value,10) || 4;
  if(window.socketClient && window.socketClient.createRoom){
    debugLog('Creating room...');
    window.socketClient.createRoom({name, maxPlayers});
  } else debugLog('socketClient not ready');
});

joinRoomBtn && joinRoomBtn.addEventListener('click', ()=>{
  const code = joinCodeInput.value.trim();
  if(!code) return alert('Ø§Ø¯Ø®Ù„ Ø±Ù…Ø² Ø§Ù„ØºØ±ÙØ©');
  if(window.socketClient && window.socketClient.joinRoom){
    debugLog('Joining room ' + code);
    window.socketClient.joinRoom({roomId: code});
  } else debugLog('socketClient not ready');
});

startRoomBtn && startRoomBtn.addEventListener('click', ()=>{
  if(window.socketClient && window.socketClient.startGame){
    window.socketClient.startGame({prodRate: parseInt(document.getElementById('prodRate').value,10) || 900});
  } else debugLog('startGame not available');
});

leaveRoomBtn && leaveRoomBtn.addEventListener('click', ()=>{
  if(window.socketClient && window.socketClient.leaveRoom){
    window.socketClient.leaveRoom();
    window.isInRoom = false;
    leaveRoomBtn.style.display = 'none';
    roomInfo.textContent = '';
    playerList.innerHTML = '';
    document.getElementById('lobby').style.display = 'flex';
    onlinePage.style.display = 'none';
  }
});

// helper to update player list UI from server state
window.updateRoomPlayers = function(players){ 
  if(!playerList) return;
  playerList.innerHTML = '';
  players.forEach(p=>{
    const li = document.createElement('li');
    li.textContent = (p.name || ('P'+(p.index+1))) + (p.isHost? ' (Host)':''); 
    // show color swatch if available
    if(p.color){
      const sw = document.createElement('span');
      sw.style.display='inline-block';
      sw.style.width='12px';
      sw.style.height='10px';
      sw.style.background = p.color;
      sw.style.marginLeft='8px';
      sw.style.borderRadius='4px';
      li.appendChild(sw);
    }
    playerList.appendChild(li);
  });
};

// expose debugLog to socket-client as well
window._debugLog = debugLog;
</script>

<script>
/* applyState and online helpers: these will be called by socket-client.js when state arrives */
window.applyState = function(state){
  try{
    if(!state) return;
    if(state.grid && Array.isArray(state.grid)){
      window.grid = state.grid;
    }
    if(state.players && Array.isArray(state.players)){
      // server provides canonical players array (including color)
      window.players = state.players.map(p=>{
        // ensure defaults
        return {
          id: p.index,
          index: p.index,
          name: p.name || ('P'+(p.index+1)),
          color: p.color || '#999999',
          capital: (typeof p.capital!=='undefined') ? p.capital : null,
          alive: (typeof p.alive!=='undefined') ? Boolean(p.alive) : true,
          isHost: !!p.isHost
        };
      });
    }

    // update local UI
    if(typeof updateLegend === 'function') try{ updateLegend(); }catch(e){}
    if(typeof window.updateRoomPlayers === 'function'){
      try{ window.updateRoomPlayers(window.players.map(p=>({index:p.index,name:p.name,isHost:p.isHost,color:p.color,capital:p.capital,alive:p.alive}))); }catch(e){}
    }

    // render quickly
    if(window.requestRender) window.requestRender(); else if(typeof window.needRender !== 'undefined') window.needRender = true;
  }catch(e){
    console.error('applyState error', e);
  }
};

window.startOnlineGame = function(state){
  try{
    if(!state) return;
    window.isOnline = true;
    window.isInRoom = true;
    // adopt server grid + players
    if(state.grid) window.grid = state.grid;
    if(state.players) {
      window.players = state.players.map(p=>({
        id: p.index, index: p.index, name: p.name || ('P'+(p.index+1)), color:p.color || '#999', capital:p.capital||null, alive:!!p.alive, isHost:!!p.isHost
      }));
    }
    // stop local bots and production
    if(window.botTimer) { clearInterval(window.botTimer); window.botTimer = null; }
    if(window.prodTimer) { clearInterval(window.prodTimer); window.prodTimer = null; }

    // show leave button
    const leaveBtn = document.getElementById('leaveRoomBtn');
    if(leaveBtn) leaveBtn.style.display = 'inline-block';

    // hide lobby, show game
    const lobby = document.getElementById('lobby');
    if(lobby) lobby.style.display = 'none';
    const onlinePage = document.getElementById('onlinePage');
    if(onlinePage) onlinePage.style.display = 'none';
    const gameCanvas = document.getElementById('game');
    if(gameCanvas) gameCanvas.style.display = 'block';

    // set camera to this player's capital if we know index
    try{
      const meIndex = window.socketClient && window.socketClient.getPlayerIndex ? window.socketClient.getPlayerIndex() : null;
      const me = (window.players||[]).find(p=>p.index===meIndex);
      if(me && typeof me.capital === 'number' && window.grid && window.grid[me.capital]){
        const cap = window.grid[me.capital];
        if(window.cam){ window.cam.x = -cap.x; window.cam.y = -cap.y; window.cam.scale = Math.max(0.9,1.0); }
      }
    }catch(e){ console.warn('camera set failed', e); }

    if(window.requestRender) window.requestRender(); else if(typeof window.needRender !== 'undefined') window.needRender = true;
  }catch(e){
    console.error('startOnlineGame error', e);
  }
};



</script>


<script>
// Auto-start online game without requiring touch
document.addEventListener("DOMContentLoaded", ()=>{
    try{
        if(window.isInRoom){
            window.gameStarted = true;
            if(window.startOnlineGame && window.lastStateFromServer){
                window.startOnlineGame(window.lastStateFromServer);
            }
            if(window.render) window.render();
        }
    }catch(e){ console.warn(e); }
});
</script>


<script>
let pingOn=false;
let lastPing=0;
let pingInterval=null;
const pingBtn=document.getElementById("pingToggle");
const pingDiv=document.getElementById("pingDisplay");

// helper to attach pong listener to current socket
function attachPongListener(sock){
  try{
    if(!sock) return;
    // avoid adding duplicate handlers
    if(sock._pongAttached) return;
    sock._pongAttached = true;
    sock.addEventListener("message", ev=>{
      try{
        const d = JSON.parse(ev.data);
        if(d && (d.type === "pong" || d.t !== undefined && d.type === "pong")){
          // compute RTT and display (keeps same UI)
          pingDiv.textContent = (Date.now() - d.t) + " ms";
        }
      }catch(e){}
    });
  }catch(e){}
}

// if socket-client sets window.socket, try to attach immediately
if(window.socket) attachPongListener(window.socket);

// also expose a small hook so socket-client can call attachPongListener after reconnects
window._attachPongListener = attachPongListener;

pingBtn.onclick=()=>{
 pingOn=!pingOn;
 if(pingOn){
   pingBtn.style.background="#0a0";
   pingDiv.style.display="block";
   // start sending pings every 1000ms
   if(pingInterval) clearInterval(pingInterval);
   pingInterval=setInterval(()=>{
     try{
       const t=Date.now();
       if(window.socket && window.socket.readyState===1){
         window.socket.send(JSON.stringify({type:"ping", t}));
       }
     }catch(e){}
   },1000);
 } else {
   pingBtn.style.background="#a00";
   pingDiv.style.display="none";
   clearInterval(pingInterval);
   pingInterval = null;
 }
};,1000);
   }
 } else {
   pingBtn.style.background="#a00";
   pingDiv.style.display="none";
   clearInterval(pingInterval);
 }
};

if(window.socket){
 window.socket.addEventListener("message", ev=>{
   try{
     const d=JSON.parse(ev.data);
     if(d.type==="pong"){
       pingDiv.textContent=(Date.now()-d.t)+" ms";
     }
   }catch(e){}
 });
}
</script>


<!-- Leaderboard Panel -->
<div id="leaderboardPanel" style="position:fixed;right:0;top:80px;width:220px;background:rgba(20,26,38,0.85);color:white;border-radius:10px 0 0 10px;padding:6px;z-index:2500;transition:transform .25s">
  <div id="leaderboardHeader" style="background:rgba(255,255,255,.08);padding:6px;text-align:center;cursor:pointer;font-weight:bold">Ø§Ù„ØªØ±ØªÙŠØ¨</div>
  <div id="leaderboardContent" style="max-height:60vh;overflow-y:auto;font-size:13px"></div>
</div>

<script>
function updateLeaderboard(){
  if(!window.players || !window.grid) return;
  const lb=document.getElementById("leaderboardContent");
  const stats=window.players.map(p=>{
    const owned=window.grid.filter(c=>c.owner===p.index).length;
    const troops=window.grid.filter(c=>c.owner===p.index).reduce((a,c)=>a+c.troops,0);
    return {name:p.name,color:p.color,owned,troops,alive:p.alive};
  }).sort((a,b)=>b.owned-a.owned);
  lb.innerHTML=stats.map(s=>\`<div style="margin:4px 0;padding:6px;background:rgba(255,255,255,.06);border-radius:6px;opacity:\${s.alive?1:.4}">
    <div style="display:flex;align-items:center;gap:6px">
      <div style="width:12px;height:12px;border-radius:3px;background:\${s.color}"></div>
      <b>\${s.name}</b>
    </div>
    <div style="font-size:11px;margin-top:2px">Ø®Ù„Ø§ÙŠØ§: \${s.owned} | Ø¬Ù†ÙˆØ¯: \${s.troops}</div>
  </div>\`).join("");
}
setInterval(updateLeaderboard,800);
document.getElementById("leaderboardHeader").onclick=()=>document.getElementById("leaderboardPanel").classList.toggle("closed");
</script>

</body>
</html>
